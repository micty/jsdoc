

##4.JavaScript 性能优化
JavaScript 是一门相当灵活自由的语言，你可以写成纯面向对象式的，也可以写成面向过程式的，甚至可以混合各种模式来使用。JavaScript 是一门动态解释执行的语言，不像静态语言可以由编译器进行编译与优化，性能问题更要注意，在写代码时要尽量帮助提升运行性能。如今主流浏览器都在比拼 JavaScript 引擎的执行速度，但最终都会达到一个理论极限，即无限接近编译后程序执行速度。 这种情况下决定程序速度的另一个重要因素就是代码本身。

###4.1数据访问优化
####4.1.1四种基本的数据存取位置
>计算机科学中的一个经典问题是如何确定数据的存储位置，以获取最佳的读写效率。数据的存储位置，关系到代码执行过程中数据被检索到的速度。在 JavaScript 中，这个问题相对简单，因为只有几种存储方案可供选择，它们会很大程度上影响到数据的读取速度。JavaScript 中有四种基本的数据存取位置：

- **直接量**。直接量只代表自身，不存储在特定位置。JavaScript 中的直接量有：字符串、数字、布尔值、对象、数组、函数、正则表达式，以及特殊的 `null` 和 `undefined` 值。
- **变量**。开发人员用关键字 var 定义的数据存储单元。
- **数组元素**。存储在 JavaScript 数组对象内部，以数字作为索引。
- **对象成员**。存储在 JavaScript 对象内部，以字符串作为索引。
访问直接量和局部变量的速度最快，相反，访问数据元素和对象成员的相对较慢。由于局部变量存在于作用域链的起始位置，因此访问局部变量比访问跨作用域变量更快。变量在作用域链中的位置越深，访问时间就越长。由于全局变量总处在作用域链的末端，因此访问速度是最慢的。

####4.1.2变量声明带上 var
如果声明变量忘记了 `var`，那么 JavaScript 引擎将会遍历整个作用域查找这个变量，结果不管找到与否，都是悲剧。如果在上级作用域找到了这个变量，上级作用域变量的内容将被无声的改写，导致莫名奇妙的错误发生。如果在上级作用域没有找到该变量，这个变量将自动被声明为全局变量，这将意外引入了一个新的全局变量。

####4.1.2慎用全局变量
全局变量要比局部变量需要搜索的作用域长，搜索时间会在循环迭代中给放大得比较明显，因此要注意在循环迭代中使用局部变量对全局变量的缓存。全局变量的生命周期比局部变量长，不利于内存释放。过多的全局变量容易造成混淆，增大产生 bug 的可能性。

####4.1.3缓存常用的对象成员、数组元素与跨域变量
通常来说，你可以把常用的对象成员、数组元素与跨域变量保存在局部变量中来改善 JavaScript 性能，因为局部变量访问速度更快。

在函数中如果要多次（特别是在循环中）读取到同一个对象属性，推荐做法是将属性值保存到局部变量中。局部变量能用来替代属性以避免多次查找带来的性能开销，特别是在处理嵌套对象成员时，这样做会明显改善执行速度。JavaScript 命名空间技术，是导致频繁访问嵌套属性的起因之一。

注意，这种方法并不适用于对象的方法，因为许多对象方法内部使用this来判断执行上下文，把一个方法保存到局部变量可能会导致 `this` 绑定到其他对象中（如 `window`），导致程序出错，除非在调用时改变调用方式，如使用 `call` 或 `apply`。

####4.1.3绝对避免使用with语句
一般来说，一个运行期的上下文作用域链是不会改变的。但是，有两个语句可以在执行时临时改变作用域链：`with` 语句、`try-catch` 语句中的 `catch` 子句。

`with` 语句用来给对象的所有属性创建了一个变量，在其他语言中，类似的功能常用来避免书写重复的代码，这看上去更高效，而实际产生了一个性能问题。当代码执行到 `with` 语句时，运行期上下文的作用域链临时被改变了。一个新的可变对象被创建，它包含了参数指定的对象的所有属性，这个对象被推入了作用域链的头部，这意味着函数的所有局部变量现在处于第二个作用域链对象中，因此访问代价更高了。

因此要绝对避免 `with` 语句的使用，因为它会改变运行期上下文的作用域链，带来性能问题。

####4.1.4最小化catch子句中的代码
由于 `try-catch` 是个非常有用的语句，因此不建议完全避免。如果你准备使用 `try-catch`，请确保你了解可能会出现的错误，该语句不应该被用来解决 JavaScript 错误。如果你知道某个错误经常出现，那说明这是代码本身应该被修复的问题。

你可以通过执行精简的代码来最小化 `catch` 子句对性能的影响。一个很好的模式是将错误委托给一个函数处理。如：

``` javascript

//推荐
try{
    //do something that may cause an error
}
catch (ex) {
    handleError(ex); //委托给处理器方法
}

```

函数 `handleError()` 是 `catch` 子句中唯一执行的代码，该函数接受错误产生的异常对象为参数，你可以用适当的方式灵活处理错误。由于只执行一条语句，且没有局部变量的访问 ，作用域链的临时改变就不会影响代码性能。

####4.1.5尽量避免使用eval语句
无论是 `with` 语句还是 `try-catch` 语句的 `catch` 子句，以及包含 `eval()` 的函数，都被认为是动态作用域。动态作用域只存在于代码执行过程中，因此无法通过静态分析即查看代码结构来检测出来。因此不运行eval()中的代码是无从获知具体情况的。

经过优化的 JavaScript 引擎，比如 Google 的 V8 引擎，尝试通过分析代码来确定哪些变量可以在特定时候被访问。这些引擎试图避开传统的作用域链的查找，取代以标识符索引的方式进行快速查找。当涉及到动态作用域时，特别是eval语句，这种优化方式就失效了，JavaScript 引擎必须切换回较慢的基于Hash表的标识符识别方式，这更像是传统的作用域链查找。

因此，应尽量避免 `eval` 语句的使用，只有确实有必要时才推荐使用。

####4.1.6减少原型链的使用
JavaScript 中的类继承是通过原型链实现的，这一概念完全不同于传统面向对象编程语言中的“类”的概念。JavaScript 对象中有两种成员类型：实例成员和原型成员。实例成员存在于对象实例中，原型成员则由对象原型继承而来。而解析对象成员的过程，会从对象实例开始，搜索该名称的成员，一旦该实例成员列表上没有该名称的成员，则会继承深入其原型链搜索原型对象的成员列表，直到找到该成员或者原型对象为空为止。

由此可见，当继承层次越多，原型链越长，对象成员在原型链中存在的位置越深，检索到它也就越慢。因此，在业务代码中，应减少“类”的使用以及继承的层次数量。通常推荐使用普通的 `Object` 对象来组织数据。

###4.2算法优化
代码的整体结构是影响运行速度的主要因素之一。代码数量少的一定运行速度快，代码数量多却也不意味着一定慢。影响性能的最直接因素是代码的组织结构以及问题的解决方法。

####4.2.1循环
对大多数编程语言而言，代码执行时间大部分消耗在循环中。循环处理一系列值是最常见的编程模式之一，因此也是提升性能必须关注的要点之一。理解JavaScript中循环对性能的影响至关重要，死循环是或长时间运行会严重影响整体用户体验。

JavaScript 提供了四种循环结构：`for`、`while`、`do-while`、`for-in`，在这四种循环类型中，只有 `for-in` 比其他几种明显要慢。

由于每次迭代操作会同时搜索实例或原型上的属性，`for-in` 循环的每次迭代都会产生更多开销，比其他循环类型都要慢。因此，除非你明确需要迭代一个属性数量未知的对象，否则应尽量避免使用 `for-in` 循环。特别注意：不要使用`for-in` 来遍历数组成员。

除 `for-in` 循环外，其他循环类型的性能都差不多，深究哪种循环最快没什么意义，循环类型的选择更应基于需求而不是性能。影响循环性能的只有两个因素：
- 每次迭代处理的工作量。
- 迭代的次数。

在实际应用中，迭代的次数基本上是确定的，因此可提升性能的集中在第一点，因此要特别注意在大循环里每次迭代中的性能优化，可以综合应用前面讨论的优化技术，仔细优化每次迭代中的代码。目前常见的是对数组的长度进行缓存，如：


``` javascript

//推荐。 
//用局部变量对数组的长度进行缓存，在进行 DOM 集合时尤其重要。
var divs = document.getElementsByTagName('divs');
for (var i = 0, len = divs.length; i < len; i++) {
    //do something...
}

```

另外不要在循环体中重复创建函数。因为每次创建一个函数对象是需要大批量空间的，所以在一个循环中创建函数是很不明智的，尽量将函数移动到循环之前创建。如：

``` javascript

//不推荐。 
//在循环体中重复创建函数。
for (var i = 0, len = list.length; i < len; i++) {
    handleItem(list[i], function () {
        //do something callback
    });
}

//推荐。 
//把函数提到循环体外创建
function callback () {
    //do something callback
}
for (var i = 0, len = list.length; i < len; i++) {
    handleItem(list[i], callback);
}

```


####4.2.2基于函数的迭代（推荐）
ECMA-262标准第四版引入了一个新的原生数组方法：`forEach()`。此方法遍历一个数组所有成员，并在每个成员上执行一个函数。要运行的函数作为 `forEach() ` 的参数传入，并在调用时接收三个参数：当前 `item`、`index` 和数组本身。如：

``` javascript
    
var items = [];

//基于函数的迭代。
items.forEach(function (item, index, items) {
    //do something...
});

```

由于浏览器的兼容性，该原生方法并没有被完全支持，因此不少优秀的 JavaScript 库都有等价的实现。如jQuery的：

``` javascript
    
//jQuery中基于函数的迭代
jQuery.each(items, function (index, item) {
    //do something
});

```

基于函数的迭代为循环迭代提供了一个更为便利的方法，从代码可维护、可阅读的角度来说，本规范推荐业务开发者优先考虑使用该方式，主要基于如下好处：
- 业务开发者可以更为专注地写每个迭代项的处理代码，而不必重复地去写循环结构，以及额外定义一个局部变量来缓存数组的长度，代码量更少。
- 循环结构变成一个语句的函数调用，代码结构更清晰明了。
- 针对每个迭代项的处理代码都在一个处理函数内部，作用域更可控，提供更多的自由来定义局部变量，而不用担心这些变量会逃逸出来而影响到循环外部。
- 处理每个迭代项的函数可以更通用，方便以后提现出来写测试用例。

从性能角度来看，对每个数组项调用外部方法会带来额外的开销（函数调用的开销），因此在运行速度要求严格时，基于函数的迭代不是最好的选择。


###4.3流程优化
条件表达式决定了JavaScript 程序的流向，其他语言对应该使用 `if-else` 还是 `switch` 语句的传统观点同样适用于 JavaScript。由于不同的浏览器针对流程控制进行了不同的优化，因此使用哪种技术更好没有定论。

####4.3.1语句if-else对比switch
是使用 `if-else` 还是 `switch` ，最流行的方法是基于测试条件的数量来判断：条件数量越大，越倾向于使用 `switch`。这是从代码的易读性考虑的，因为当判断条件较少时 `if-else` 更易读；反之 `switch` 的结构更清晰易读。如：

``` javascript

//推荐。 判断条件较少时，优先使用 if-else 结构。
if (found) {
    //do something
}
else {
    //do something else
}

//不推荐。 判断条件较少时，不适合用 switch 结构。
switch (found) {
    case true:
        //do something
        break;
    default:
        //do something else
        break;
}


var color;

//不推荐。 判断条件较多时，不适合用 if-else 结构。
if (color == 'red') {
    //...
}
else if (color == 'blue') {
    //...
}
else if (color == 'yellow') {
    //...
}
else if (color == 'black') {
    //...
}
else {
    //...
}

//推荐。 判断条件较多时，优先使用 switch 结构。
switch (color) {
    case 'red':
        //...
        break;
    case 'blue':
        //...
        break;
    case 'yellow':
        //...
        break;
    case 'black':
        //...
        break;
    default:
        //...
        break;
}
    
```

从性能角度来看，大多数情况下 `switch` 比 `if-else` 运行得要快，但只有当条件数量很大时才明显。主要原因是，在 JavaScript 中，`switch` 语句比较值时使用的是全等操作，不会发生类型转换的损耗。

因此，通常来说，`if-else` 适用于判断两个离散值或几个不同的值域；当判断多于两个离散值时，`switch` 更合适。


####4.3.2优化 `if-else`
优化 `if-else` 的目标是：最小化到达正确分支前所需要判断的条件数量。最简单的优化方法是确保最可能出现的条件放在首位，即 `if-else` 中的条件语句应该总是按照从最大概率到最小概率的顺序排列，以确保运行速度最快。

####4.3.3使用查找表
当有大量离散值需要判断时，最佳方案是使用查找表。JavaScript 中可以用数组和普通的 `Ojbect` 对象来构造查找表，通过查找表访问数据比 `if-else` 和 `switch` 都要快很多，特别是在条件数量很大的时候。而且，查找表结构的代码可读性更好。

``` javascript

//定义一系列离散值对应的处理函数
var handlers = {
    'red': function () {
        //处理 case 为 'red' 的分支
    },
    'blue': function () {
        //处理 case 为 'blue' 的分支
    },
    'yellow': function () {
        //处理 case 为 'yellow' 的分支
    },
    'black': function () {
        //处理 case 为 'black' 的分支
    }
};

//1.命名模式： 对每个函数进行命名。会产生两个中间的局部变量。
var fn = handlers[color] || function () {
    //处理 default 的分支
};
fn();

//2.混合模式：立即函数 + 声明即调用混合模式。 产生一个中间局部变量。
(handlers[color] || function () {
    //处理 default 的分支
})();


//3.完全的声明即调用模式：追求极致的，不产生任何中间的局部变量。
(({
    'red': function () {
        //处理 case 为 'red' 的分支
    },
    'blue': function () {
        //处理 case 为 'blue' 的分支
    },
    'yellow': function () {
        //处理 case 为 'yellow' 的分支
    },
    'black': function () {
        //处理 case 为 'black' 的分支
    }
})[color] || function () {
    //处理 default 的分支
})();
    
```

当你使用查找表时，必须完全抛弃条件判断语句。这个过程变成数组项查询或对象成员查询。查找表的一个主要优点是：不用书写任何条件判断语句，即使离散值数量增加时，也几乎不会产生额外的性能开销。当单个键和单个值之间存在逻辑映射时，查找表的优势就能体现出来。`switch` 语句更适合于每个键都需要对应一个独特的动作或一系列的动作的场合。

###4.4一些优化建议

####4.4.1避免动态执行字符串代码
JavaScript 允许你动态去执行一个字符串代码，它比直接执行代码的速度慢很多，因为它要创建一个新的解释器/编译器实例，这必然使得代码执行速度变慢。

大多数时候，没有必要使用 `eval()` 和 `Function()`，因此最好避免使用它们。另外，对于 `setTimeout()` 和 `setInterval()`，建议传入函数的而不是字符串作为第一个参数。

####4.4.2使用直接量
在 JavaScript 中创建对象和数组的方法有多种，但使用直接量是最快的方法。字面量是引擎直接解释执行的，而如果使用构造函数的话，需要调用一个内部构造器。最重要一点，使用直接量有助于节省代码量，代码也更易读，数据结构更清晰。数据量越大，使用直接量的处好就越明显。

####4.4.3使用原生方法
无论你的 JavaScript 代码如何优化，都永远不会比 JavaScript 引擎提供的原生方法更快。因为，JavaScript 的原生部分是用低级语言（如C++）写的，并被编译成机器码，成为执行环境（如浏览器）的一部分，所以不会像你写的 JavaScript 代码那样受到各种限制。

当原生方法可用时，尽量使用它们。特别是数学运算和 DOM 操作。用编译后的代码做越多的事情，你的代码就越快。

####4.4.4使用布尔表达式的短路
在很多语言中，如果 `bool` 表达式的值已经能通过前面的条件确定，那么后面的判断条件将不再会执行。因此，可以对多个 `&&` 和多个 `||` 操作的布尔表式进行位置上的排列优化：

- 多个 `&&` 操作：尽量把能确定为 `false` 的子表达式放在前面。当前面有一个为 `false` 时，整个表达式的值为 `false`，后面的子表达式将不会计算；
- 多个 `||` 操作：尽量把能确定为 `true` 的子表达式放在前面。当前面有一个为 `true` 时，整个表达式的值为` true`，后面的子表达式将不会计算；

####4.4.5让垃圾回收器回收那些不再需要的对象
如果长时间保存对象，老生代中占用的空间将增大，每次在老生代中的垃圾回收过程将会相当漫长。在某些时候我们可以通过手动消除引用关系来让垃圾回收器对回收这些对象。

- `delete`。一种方式是通过 `delete` 方式来消除对象中的键值对，从而消除引用。但这种方式并不提倡，它会改变对象的结构，可能导致引擎中对对象的存储方式变更，降级为字典方式进行存储，不利于JavaScript引擎的优化，所以尽量减少使用。
- `null`。另一种方式是通过将值设为 `null` 来消除引用。通过将变量或对象的属性设为 `null`，可以消除引用，使原本引用的对象成为一个“孤岛”，然后在垃圾回收的时候对其进行回收。这种方式不会改变对象的结构，比使用 `delete` 要好。

####4.4.6不要重复工作
对于一些比较复杂的计算，当相同的参数输入会得到相同的结果输出时，我们可以在函数内部把计算结果缓存起来。在下次进行同样的参数输入时，可以直接从缓存中读取结果，避免重复计算。这是一种典型的以空间换时间的策略，可以减少响应时间，提升用户体验。该方式适用于：
- 相同的参数输入会得到相同的结果输出；
- 能牺牲一定的内存空间；

-----------------------------------------------------------------------------------
