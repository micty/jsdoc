
#JavaScript开发规范
---------------------------------------------------------------
##1.绪论
JavaScript 是一门语法极其灵活的语言，简单易懂，对代码的格式的要求也相对松散。语法松散是 JavaScript 重要的特征。它灵活易懂，给开发人员带来了很多方便，但如果编写过程中不注意，代码的调试成本和维护成本则会无形地增加。也正因为如此，JavaScript 的编码规范也往往被轻视，开发过程中修修补补，最终也就演变成为后续维护人员的恶梦。软件存在的长期价值直接与编码的质量成比例，编码规范能帮助我们降低编程中不必要的麻烦。

为提高前端团队的协作性，降低代码的调试和维护成本，提高代码安全和执行效率，特制定本规范文档。良好的JavaScript开发规范的核心是编写可维护的代码，即代码是可读的、一致的、可预测的、看起来像是同一个人写的、有文档的。这也是我们前端团队追求的目标之一。


##2.JavaScript代码格式
关于JavaScript，你必须知道，你不是一个人在战斗，所有的代码都要变成可供他人容易阅读的。在一个软件的整个生命周期里，一个程序可能会被许多人阅读或修改。如果一个程序可以清晰的展现出它的结构和特征，那就能减少在以后对其进行修改时出错的可能性。JavaScript的代码格式是给代码阅读者最直观的感受，直接影响到阅读心情和效率。良好的代码格式不仅体现代码编写者的清晰的逻辑思维，更体现了一个人的外在美与爱美之心。

JavaScript的代码格式化工具有很多，包括各种IDE开发工具自身都内置了一套默认的格式。为了协同团队一致性，特拟定以下代码格式，请自行设置好自己的IDE开发工具。

###2.1 缩进
关于缩进的问题，不只是 JavaScript，几乎所有的语言编写的时候，都会提及缩进的问题。缩进几乎是代码编写规范的第一课，是代码可阅读性判断的直接因素。代码缩进的好处是不言而喻的，但是对于如何缩进，则没有标准而言。最受欢迎的是方便使用 TAB 键缩进，也有些喜欢用 2 个、4 个、8 个空格进行缩进。这样缩进风格不一，也同样给代码的阅读带来障碍。

本规范提倡用4个空格来进行缩进，并在同一产品中采用同一种缩进标准。不支持用 Tab 键进行缩进，这是因为直到现在还没有统一的标准来定义 Tab 所代替的空白大小，有些编辑器解析为4个空格大小，有些则解析为8个。因而用不同的编辑器查看代码，可能造成格式混乱。当然 Tab 简单易用，为解决这个问题，建议在设置开发环境时，将编辑器里的 Tab 快捷键重新设置为4个空格。

###2.2 行长度
每行代码应尽量不超过 80 个字符。如果代码较长，应尽量选择换行，下一行代码应缩进 8 个空格。这样可以使代码排版整齐，减轻阅读代码的疲劳感。换行缩进 8 个空格可以和代码段的缩进 4 个空格区分开，以增强代码的可阅读性。

如果代码行较长需要换行的时候，换行应选择在操作符和标点符号之后，最好是在逗号之后，而不要在变量名、字符串、数字、或')' ']' '++' '--'等符号之后换行。这样可以有效的防止拷贝、粘贴而引起的错误，并可有效地增强代码的可阅读性。

###2.3多个变量的声明格式
多个变量的声明格式主要分单 var 模式和多 var 模式，两种方式各有其优缺点。不管何种方式，为避免意外引入或修改了全局变量，所有的变量在使用前必须通过 var 关键字进行声明。

####2.3.1单 var 模式（不推荐）
单 var 模式逗号风格的兴起，是 NCZ 在2009 年介绍 YUI Compressor 压缩原理时提到的。NCZ 倡导：为了帮助压缩工具实现更好的压缩，倡导一个函数内，尽量只保持一个 var 和 return。然而，目前高级压缩器，Closure Compiler 和 UglifyJS 等，都能自动处理 var 了，在压缩函数时，会自动做变量提升和 var 单一化。因此尽量保持一个 var 的最佳实践，目前已不是最佳实践，大方向肯定是更人性化、更自然化的写法，优化交给工具就好。

单 var 模式的推荐在函数开始处把函数内要用到的所有变量一次性声明出来，并且通过逗号进行分隔。如：

``` javascript
    //不推荐
    var cache, len, all, list, args = [], event, i;

```

如果赋值语句较长或变量比较多，目前有一种写法是用逗号换行：

``` javascript

    //不推荐
    function fn() {
        
        var count = 10,
            name = "Nicholas",
            found = false,
            map = {},
            list = [],
            get = function () {
                //...
                //这个函数可能很长很长
            },
            //...
            //这里可能还会有很多个变量，占据很多行
            empty;
        
        //do something...

    }

```

单 var 模式的最大优点是可以比较集中的清晰看到一个函数内要用到的所有变量，并且可以避免意外引入或修改了全局变量。但这种方式本规范不推荐使用，原因有：
- 1.当变量过多时，占据的篇幅行数就会过多，代码阅读者看到最后，容易忘记这是一个局变量还是一个全局变量，甚至当成写错了格式的key: value形式的Object对象成员；
- 2.不容易在后期进行修改，比如要把某个变量迁移到其他位置时，因为其前面缺少 var 关键字，并且后面是个逗号，修改起来麻烦，容易变成全局变量；
- 3.人的记忆范围有限，一次性声明过多变量会加重代码阅读者（甚至代码编写者）的记忆压力，造成混淆，当在后面看到某个变量时，得向前翻查该变量定义的位置以及初始值，跳跃空间太大，容易打断阅读者的思维。

####2.3.2多 var 模式（推荐）
吐槽太多不利身心健康，为解决上述问题，本规范推荐使用多 var 模式进行变量声明：
- 1.一个变量对应一个var 关键字开始和一个分号结束；
- 2.按需声明，在第一次需要使用该变量时即声明；
- 3.变量声明的位置尽量靠近第一次使用时的位置；
- 4.变量尽量按类型给定初始值(看情况)。

``` javascript

    //推荐。 按需声明变量，变量声明的位置与使用的位置尽量靠近
    function fn() {

        //不推荐
        var cache, event, all, list, i, len, rest = [], args;

        var count = 10;
        var name = 'Nicholas';
        console.log(name + '=' + count);

        var map = {};
        var list = [];
        var found = name in map;
        if (found) {
            list.push(name);
        }

        var get = function () {
            //...
            //这个函数可能很长很长
        };

        var empty;

        //do something...

    }

```

多 var 模式更符合人类思维的局部记忆原理，把最相关的代码组织在位置最近的地方，代码逻辑更不容易出错，以后要移除某段逻辑时，只需要关注某一段代码即可，做代码重构（比如提取函数）时，也更方便。

###2.4 花括号

关于花括号的格式一直比较受争议，习惯写后台程序的同学可能比较喜欢首花括号换行，这样显示得比较有对称美。为了适应前端业界大多数的习惯，本规范里的首花括号不换行，这也在某些方面可以避免解析错误。

``` javascript

    //推荐
    if (foo) {
        
    }

    //不推荐，首花括号不需要换行
    if (foo)
    {

    }

    //不推荐，首花括号不需要换行
    var obj =
    {

    };
    
```

为方便阅读和以后增加代码，凡是有代码块的地方，如条件判断、循环等，不管语句的多少，都要用花括号括起来。如：

``` javascript

    //推荐
    if (foo) {
        return;
    }

    //不推荐，没有换行缩进，结构不明朗
    if (foo) return;

    //不推荐，有换行与缩进，但没有块效果，不方便以后增加语句并且容易出错
    if (foo)
        return;
        
```

###2.5 空白符
适当的空白行可以大大提高代码的可阅读性，可以使代码逻辑更清晰易懂。同时，在表达式中适当的留空白，也会给代码的阅读带来方便。
操作符之间前后各需要一个空格。如

``` javascript

    //推荐
    var x = y + z;

    //不推荐，太密集
    var x=y+z;
        
```

对象立即量{}中的成员里，冒号前无空格，冒号后只空一格。如：

``` javascript

    //推荐
    var obj = {
        a: 1,
        longname: 2
    };

    //不推荐
    var obj = {
        a:1,            //太密集，冒号后需要一个空格
        b : 2,          //太松散，冒号前不需要空格
        c       : 3,    //不需要刻意去对齐，因为在未来不可控
        longname: 4 
    };
        
```

逗号的后面需要留空白，以显示明确的参数间隔，变量间隔等。函数定义分匿名函数与具名函数，匿名函数的圆括号前后都需要一个空格；而具名函数的前圆括号不需要。并且函数中的多个参数都要用带空格的逗号分隔。如：

``` javascript

    //推荐
    var fn = function (a, b, c) {

    };

    //推荐
    function fn(a, b, c) {

    }

    //不推荐，原因：
    //1.左圆括号不能紧跟 function 关键字；
    //2.右圆括号跟函数体开始的花括号需空一格；
    //3.参数间的逗号需要空一格，不然太密集
    var fn = function(a,b,c){

    };

    //不推荐
    //具名函数名后面的左圆括号不需要空一格，并且参数前后空格太多。
    function fn ( a, b, c ) {

    }
        
```

函数调用的，函数名称后面不需要空格。如：

``` javascript
    //推荐
    fn(0, 1, 2);

    //不推荐，参数间太密集，需要空格
    fn(0,1,2);

    //不推荐，函数调用的函数名称后面不需要空格
    fn (0, 1, 2);
      
```

###2.6 语句必须以分号结束
所有JavaScript语句必须以分号结束，以防止在压缩与精简代码时出错。同时，一行代码最多有一个语句。如果一个赋值语句是用函数、对象、数组来赋值，可能会跨多行，一定切记要在赋值语句末加上分号。

这是因为 JavaScript 中，所有表达式都可以当语句，遇换行符时会解析为表达式的结束，此时不规范的换行和分号的丢失，可能引入新的错误。

``` javascript

    //推荐
    var obj = {
        
    };

    //推荐
    var array = [

    ];

    //推荐
    var fn = function () {

    }; //通过这种方式定义函数，结束处的分号不能少


    //不推荐
    var fn = function () {

    } // <--缺少分号

    //不推荐
    function fn() {

    }; //不是通过 var 定义的函数结束处，不需要分号
    
```
###2.7 单引号与双引号
在JavaScript中，字符串可以用单引号括起来，也可以用双引号括起来。考虑到HTML中的属性值的引号使用情况，本规范推荐JavaScript中的字符串统一用单引号括起来；HTML中的属性值用双引号括起来。这样可以最大程度减少转义符的使用，让代码更易读与美观。如：

``` javascript
    
    var name = 'Nichlas says: "hi" ';

```

``` html
    <a href="showDetail('test')">显示详情<a/>
```

##3.JavaScript命名规范
命名对JavaScript代码可读性至关重要，良好的命名风格能极大提高代码阅读者理解代码的速度。在业界中，JavaScript的命名没有统一的规范，即使是几个流行的框架，如jQuery、ExtJs、Backbone，命名风格也不尽一致，尽管如此，一些共有的约定俗成的规范还存在的，我们也应当遵守并保持习惯。

###3.1 标识符命名
JavaScript 中的标识符的命名规则
- 以字母、下划线'_'或美元符号'$'开头
- 允许名称中包含字母，数字，下划线'_'和美元符号'$'
- 区分大小写

###3.2推荐的命名规范

####3.2.1变量名
变量名尽量采用有意义的英文单词或缩写命名，不要用拼音。某些特殊的业务模块，可考虑采用拼音或拼音缩写，但应该尽量减少这种情况的发生。
函数命名应尽量以动词开头，并能体现函数完成的功能。类名（构造函数）、模块名、命名空间则以名词开头，表示是一个什么样的事物。
由于JavaScript是一种弱类型语言，在一些团队里，由于历史原因，特别是习惯写C++的人，喜欢给变量名加一个前缀表示变量的数据类型，此种命名方式叫匈牙利命名法。匈牙利命名法是一位微软程序员发明的，多数的C 和 C++程序都使用此命名法。
本规范不推荐匈牙利命名法，因为它并没有发挥JavaScript动态语言的特性，即使同一个变量名，也可以使用在不同环境里，具有不同的数据类型。强制给变量名加上表示数据类型的前缀，既没必要，更影响代码阅读者的视线，起到干扰的作用。
良好的命名风格即可预示着变量的作用，更可暗示它的数据类型。

####3.2.2大小写
变量、参数、成员变量、函数等名称均以小写字母开头；
命名空间、模块、构造器的名称以大写字母开头；

####3.2.3单词组合
多个单词组合的采用采用首字母小写，其它单词首字母大写的驼峰式命名，尽量不要使用下划线连接符。如：

``` javascript
    //推荐
    var userName = 'Nicholas';
    function addYears() {

    }

    //不推荐
    var user_name = 'Nicholas';
    function add_years() {

    }
```

####3.2.4下划线
**原则：尽量减少下划线的使用；内部变量命名禁止以下划线开头。**

某些特殊情况下，当一个模块/对象不得不暴露一个私有成员时（如为了方便调试），为了表示区分与警告，应以下划线开头，但应尽量减少这种情况的发生。如果你的代码逻辑要暴露过多的以下划线开头的成员，请重新审查你的设计模式，肯定有改善的空间，比如可以改成使用内部使用的辅助工具类来存取私有成员数据。

``` javascript

    //不推荐
    function fn() {
        var _age = 20;          //不需要下划线
        var name_ = 'Nicholas'; //不需要下划线
    }


    //推荐
    function fn() {
        var age = 20;
        var name = 'Nicholas';

        return {
            name: name, //公共成员，正常暴露
            _age: age   //不得不暴露私有成员时，必须以下划线开头
        };
    }
    
```

某些场景下需要以下划线开头，如后台接口返回的全局变量或通过后台生成的JS数据文件，必须以全局变量出现时，就必须以下划线开头，这样可以尽可能的减少数据产生的全局变量与业务代码的冲突。假设有一个后台程序会在每天夜里定时运行，扫描业务数据库并按一定格式生成 JS 数据文件，推荐的顶级变量命名方式为：分别以两个下划线开头和结束。如：


``` javascript

    //推荐
    //后台程序生成的 JS 数据文件格式
    //增加一个全局变量，是一个数据，分别以两个下划线开头和结束
    var __data__ = [ 

        //...

    ];

    //推荐
    var __data__ = {

        //...

    };

    //推荐
    //后台接口返回的 JSON-P 格式
    __callback__({ //业务代码必须已定义一个名为 __callback__ 的函数

        //...
    });
    
```


####3.2.5美元符号$
以美元符号“$”开头的变量习惯于标识系统相关，比如系统进程等，应该尽量在业务代码中使用，jQuery框架的命名空间除外。
在这里推荐一种使用$符号的情况，在JavaScript中，经常会遇到使用一个Object对象{…} 来存储一个key及其对应的value，使用时再根据key取出它的value。这是JavaScript内置实现的一个hash存储机制，非常好用，应尽量使用它，我们把它称为一个map。
在JavaScript中，检索数组的时间复杂度为O(n)，而检索Object的时间复杂度为O(1)，随着n的增大，通过Object存储数据的优势就体现出来了。为了更清晰的表示出该Object 的 map的结构，推荐使用以下格式：key$value = {};
假如需要动态建立起一个用户列表集合，通过 id 唯一确定一个user值，可以定义该map为：


``` javascript

    //推荐使用的 key-value 集合表示法
    var id$user = {
        1000: { name: 'Micty', age: 30 },
        1001: { name: 'Nicholas', age: 30 },
        1002: { name: 'Bill', age: 30 }
        //...
    };

    //取出 id 为 1001 的值
    var id = 1001;
    var user = id$user[id];
    
```

以下是在一个框架里使用的示例：


``` javascript

    //一对一的关系
    var name$data = {};         //维护 { className: data } 这样的原始集合
    var name$superName = {};    //维护 { className: 直接父类 className } 的关系
    var xtype$superXtype = {};  //维护 { xtype: 直接父类 xtype } 的关系
    var xtype$name = {};        //维护 { xtype: className } 的关系
    var name$class = {};        //维护 { className: constructor} 的关系，对 singleton 的特别有用
    var name$config = {};       //维护 { className: 自上而下合并后的 config } 的关系，实现字段继承

    //一对多的关系
    var name$childNames = {};   //维护 { clasName: [直接子类className] } 的关系
    var xtype$childXtypes = {}; //维护 { xtype: [直接子类xtype] } 的关系
    
```

通过key$value 的命名方式可以很清晰的理解该map的作用。

###3.3一些常见的命名场景
变量命名有时是一件挺头疼的事，毕竟要创造出一个合适的名字并不是一件简单的事，但也不必拘泥于规范中的条条框框限制，可根据代码环境作适当变通。当逻辑比较简单明了，代码比较清晰时，可以使用一些简单的名称来表示，如数组的可以用var list 或 var a来表示；函数的可以用var fn来表示；对象的可以用var obj来表示。简单明了的命名有时能起到简化代码逻辑效果。

####3.3.1数组
数组是一个复数，可以在单数变量后加s表示是复数；也可以直接简单用var list来表示；甚至在某些足够简单的上下文里，可以直接用 var a 来表示。如：

``` javascript

    //推荐的复数命名方式
    var ids = [];   //表示 id 的集合
    var events = [];//表示事件的集合

    var list = [];  //表示一个列表集合，用在语义很明确的环境里
    var a = [];     //表示一个数组，用在代码逻辑足够简单的环境里
    
```

####3.3.2函数
函数命名应尽量以动词开头，并能体现函数完成的功能。在参数里、函数内部，在不引起歧义的情况下，可以简单的以fn来表示一个函数，如：


``` javascript

    //推荐。 函数作为简单的参数时的命名
    function doSomthing(fn) {
        //...
        fn(); //回调
    }

    //推荐。 函数引用自身时的命名
    function doSomthing() {
        var fn = arguments.callee; //引用自身
        //...
    }
    
```

下面列举一些常用的命名：
- 转换数据类型的，以to开头，如 toString、toUtf8、toArray、toObject等；
- 解析数据的为 parse；
- 初始化的为initialize或init；
- 查找的为find；
- 格式化的为format；
- 过滤的为grep；
- 判断结果为bool值的有contains、startsWith、endsWith、exits等；
- 渲染UI的为render；
- 常见的成对的动词有 get/set、add/remove、create/destroy、start/stop、begin/end、on/off、bind/unbind、next/previous；

####3.3.3对象
对象的命名应该是一个名词，复数的情况可以在后面加s来表示。在某些简单上下文里，可以直接用var obj 来表示。
在类的内部，当要用局部变量来引用this变量时，推荐使用self命名，如：

``` javascript

    var self = this;
    
```

####3.3.4模块
模块是一个比库还小的概念，而一个框架可能包含几个库。模块更适合对业务代码进行划分与组织，从逻辑上清晰的表达业务功能的结构与层次。
JavaScript里没有严格的“模块”的定义，所有的模块的实现，只是通过一个闭包函数来返回一个暴露了一些成员的Object对象。本规范推荐模块命名以大写字母开头，如：

``` javascript

    //推荐。 模块的命名，以大写字母开头
    var ClassManager = (function () {

        //some code...

        //ClassManager = 
        return {

            //...
        };
    })();
    
```

##4.JavaScript性能优化
JavaScript是一门相当灵活自由的语言，你可以写成纯面向对象式的，也可以写成面向过程式的，甚至可以混合各种模式来使用。JavaScript是一门动态解释执行的语言，不像静态语言可以由编译器进行编译与优化，性能问题更要注意，在写代码时要尽量帮助提升运行性能。如今主流浏览器都在比拼JavaScript引擎的执行速度，但最终都会达到一个理论极限，即无限接近编译后程序执行速度。 这种情况下决定程序速度的另一个重要因素就是代码本身。

###4.1数据访问优化
####4.1.1四种基本的数据存取位置
>计算机科学中的一个经典问题是如何确定数据的存储位置，以获取最佳的读写效率。数据的存储位置，关系到代码执行过程中数据被检索到的速度。在JavaScript中，这个问题相对简单，因为只有几种存储方案可供选择，它们会很大程度上影响到数据的读取速度。JavaScript中有四种基本的数据存取位置：
	直接量。直接量只代表自身，不存储在特定位置。JavaScript中的直接量有：字符串、数字、布尔值、对象、数组、函数、正则表达式，以及特殊的null和undefined值。
	变量。开发人员用关键字var定义的数据存储单元。
	数组元素。存储在JavaScript数组对象内部，以数字作为索引。
	对象成员。存储在JavaScript对象内部，以字符串作为索引。
访问直接量和局部变量的速度最快，相反，访问数据元素和对象成员的相对较慢。由于局部变量存在于作用域链的起始位置，因此访问局部变量比访问跨作用域变量更快。变量在作用域链中的位置越深，访问时间就越长。由于全局变量总处在作用域链的末端，因此访问速度是最慢的。

####4.1.2变量声明带上var
如果声明变量忘记了var，那么JavaScript引擎将会遍历整个作用域查找这个变量，结果不管找到与否，都是悲剧。如果在上级作用域找到了这个变量，上级作用域变量的内容将被无声的改写，导致莫名奇妙的错误发生。如果在上级作用域没有找到该变量，这个变量将自动被声明为全局变量，这将意外引入了一个新的全局变量。

####4.1.2慎用全局变量
全局变量要比局部变量需要搜索的作用域长，搜索时间会在循环迭代中给放大得比较明显，因此要注意在循环迭代中使用局部变量对全局变量的缓存。全局变量的生命周期比局部变量长，不利于内存释放。过多的全局变量容易造成混淆，增大产生bug的可能性。

####4.1.3缓存常用的对象成员、数组元素与跨域变量
通常来说，你可以把常用的对象成员、数组元素与跨域变量保存在局部变量中来改善JavaScript性能，因为局部变量访问速度更快。
在函数中如果要多次（特别是在循环中）读取到同一个对象属性，推荐做法是将属性值保存到局部变量中。局部变量能用来替代属性以避免多次查找带来的性能开销，特别是在处理嵌套对象成员时，这样做会明显改善执行速度。JavaScript命名空间技术，是导致频繁访问嵌套属性的起因之一。
注意，这种方法并不适用于对象的方法，因为许多对象方法内部使用this来判断执行上下文，把一个方法保存到局部变量可能会导致this绑定到其他对象中（如window），导致程序出错，除非在调用时改变调用方式，如使用call或apply。

####4.1.3绝对避免使用with语句
一般来说，一个运行期的上下文作用域链是不会改变的。但是，有两个语句可以在执行时临时改变作用域链：with语句、try-catch语句中的catch子句。
with语句用来给对象的所有属性创建了一个变量，在其他语言中，类似的功能常用来避免书写重复的代码，这看上去更高效，而实际产生了一个性能问题。当代码执行到with语句时，运行期上下文的作用域链临时被改变了。一个新的可变对象被创建，它包含了参数指定的对象的所有属性，这个对象被推入了作用域链的头部，这意味着函数的所有局部变量现在处于第二个作用域链对象中，因此访问代价更高了。
因此要绝对避免with语句的使用，因为它会改变运行期上下文的作用域链，带来性能问题。

####4.1.4最小化catch子句中的代码
由于try-catch是个非常有用的语句，因此不建议完全避免。如果你准备使用try-catch，请确保你了解可能会出现的错误，该语句不应该被用来解决JavaScript错误。如果你知道某个错误经常出现，那说明这是代码本身应该被修复的问题。
你可以通过执行精简的代码来最小化catch子句对性能的影响。一个很好的模式是将错误委托给一个函数处理。如：

``` javascript

    //推荐
    try{
        //do something that may cause an error
    }
    catch (ex) {
        handleError(ex); //委托给处理器方法
    }

```

函数handleError()是catch子句中唯一执行的代码，该函数接受错误产生的异常对象为参数，你可以用适当的方式灵活处理错误。由于只执行一条语句，且没有局部变量的访问 ，作用域链的临时改变就不会影响代码性能。

####4.1.5尽量避免使用eval语句
无论是with语句还是try-catch语句的catch子句，以及包含eval()的函数，都被认为是动态作用域。动态作用域只存在于代码执行过程中，因此无法通过静态分析即查看代码结构来检测出来。因此不运行eval()中的代码是无从获知具体情况的。
经过优化的JavaScript引擎，比如Google的V8引擎，尝试通过分析代码来确定哪些变量可以在特定时候被访问。这些引擎试图避开传统的作用域链的查找，取代以标识符索引的方式进行快速查找。当涉及到动态作用域时，特别是eval语句，这种优化方式就失效了，JavaScript引擎必须切换回较慢的基于Hash表的标识符识别方式，这更像是传统的作用域链查找。
因此，应尽量避免eval语句的使用，只有确实有必要时才推荐使用。

####4.1.6减少原型链的使用
JavaScript中的类继承是通过原型链实现的，这一概念完全不同于传统面向对象编程语言中的“类”的概念。JavaScript对象中有两种成员类型：实例成员和原型成员。实例成员存在于对象实例中，原型成员则由对象原型继承而来。而解析对象成员的过程，会从对象实例开始，搜索该名称的成员，一旦该实例成员列表上没有该名称的成员，则会继承深入其原型链搜索原型对象的成员列表，直到找到该成员或者原型对象为空为止。
由此可见，当继承层次越多，原型链越长，对象成员在原型链中存在的位置越深，检索到它也就越慢。因此，在业务代码中，应减少“类”的使用以及继承的层次数量。通常推荐使用普通的Object对象来组织数据。

###4.2算法优化
代码的整体结构是影响运行速度的主要因素之一。代码数量少的一定运行速度快，代码数量多却也不意味着一定慢。影响性能的最直接因素是代码的组织结构以及问题的解决方法。

####4.2.1循环
对大多数编程语言而言，代码执行时间大部分消耗在循环中。循环处理一系列值是最常见的编程模式之一，因此也是提升性能必须关注的要点之一。理解JavaScript中循环对性能的影响至关重要，死循环是或长时间运行会严重影响整体用户体验。
JavaScript提供了四种循环结构：for、while、do-while、for-in，在这四种循环类型中，只有for-in比其他几种明显要慢。
由于每次迭代操作会同时搜索实例或原型上的属性，for-in循环的每次迭代都会产生更多开销，比其他循环类型都要慢。因此，除非你明确需要迭代一个属性数量未知的对象，否则应尽量避免使用for-in循环。特别注意：不要使用for-in来遍历数组成员。
除for-in循环外，其他循环类型的性能都差不多，深究哪种循环最快没什么意义，循环类型的选择更应基于需求而不是性能。影响循环性能的只有两个因素：
	- 每次迭代处理的工作量。
	- 迭代的次数。
在实际应用中，迭代的次数基本上是确定的，因此可提升性能的集中在第一点，因此要特别注意在大循环里每次迭代中的性能优化，可以综合应用前面讨论的优化技术，仔细优化每次迭代中的代码。目前常见的是对数组的长度进行缓存，如：


``` javascript

    //推荐。 
    //用局部变量对数组的长度进行缓存，在进行 DOM 集合时尤其重要。
    var divs = document.getElementsByTagName('divs');
    for (var i = 0, len = divs.length; i < len; i++) {
        //do something...
    }

```

另外不要在循环体中重复创建函数。因为每次创建一个函数对象是需要大批量空间的，所以在一个循环中创建函数是很不明智的，尽量将函数移动到循环之前创建。如：

``` javascript

    //不推荐。 
    //在循环体中重复创建函数。
    for (var i = 0, len = list.length; i < len; i++) {
        handleItem(list[i], function () {
            //do something callback
        });
    }

    //推荐。 
    //把函数提到循环体外创建
    function callback () {
        //do something callback
    }
    for (var i = 0, len = list.length; i < len; i++) {
        handleItem(list[i], callback);
    }

```


####4.2.2基于函数的迭代（推荐）
ECMA-262标准第四版引入了一个新的原生数组方法：forEach()。此方法遍历一个数组所有成员，并在每个成员上执行一个函数。要运行的函数作为 forEach() 的参数传入，并在调用时接收三个参数：当前item、index和数组本身。如：

``` javascript
    
    var items = [];

    //基于函数的迭代。
    items.forEach(function (item, index, items) {
        //do something...
    });

```

由于浏览器的兼容性，该原生方法并没有被完全支持，因此不少优秀的JavaScript库都有等价的实现。如jQuery的：

``` javascript
    
    //jQuery中基于函数的迭代
    jQuery.each(items, function (index, item) {
        //do something
    });

```

基于函数的迭代为循环迭代提供了一个更为便利的方法，从代码可维护、可阅读的角度来说，本规范推荐业务开发者优先考虑使用该方式，主要基于如下好处：
	- 业务开发者可以更为专注地写每个迭代项的处理代码，而不必重复地去写循环结构，以及额外定义一个局部变量来缓存数组的长度，代码量更少。
	- 循环结构变成一个语句的函数调用，代码结构更清晰明了。
	- 针对每个迭代项的处理代码都在一个处理函数内部，作用域更可控，提供更多的自由来定义局部变量，而不用担心这些变量会逃逸出来而影响到循环外部。
	- 处理每个迭代项的函数可以更通用，方便以后提现出来写测试用例。

从性能角度来看，对每个数组项调用外部方法会带来额外的开销（函数调用的开销），因此在运行速度要求严格时，基于函数的迭代不是最好的选择。


###4.3流程优化
条件表达式决定了JavaScript程序的流向，其他语言对应该使用if-else还是switch语句的传统观点同样适用于JavaScript。由于不同的浏览器针对流程控制进行了不同的优化，因此使用哪种技术更好没有定论。

####4.3.1语句if-else对比switch
是使用if-else还是switch，最流行的方法是基于测试条件的数量来判断：条件数量越大，越倾向于使用switch。这是从代码的易读性考虑的，因为当判断条件较少时if-else更易读；反之switch的结构更清晰易读。如：

``` javascript

    //推荐。 判断条件较少时，优先使用 if-else 结构。
    if (found) {
        //do something
    }
    else {
        //do something else
    }

    //不推荐。 判断条件较少时，不适合用 switch 结构。
    switch (found) {
        case true:
            //do something
            break;
        default:
            //do something else
            break;
    }


    var color;

    //不推荐。 判断条件较多时，不适合用 if-else 结构。
    if (color == 'red') {
        //...
    }
    else if (color == 'blue') {
        //...
    }
    else if (color == 'yellow') {
        //...
    }
    else if (color == 'black') {
        //...
    }
    else {
        //...
    }

    //推荐。 判断条件较多时，优先使用 switch 结构。
    switch (color) {
        case 'red':
            //...
            break;
        case 'blue':
            //...
            break;
        case 'yellow':
            //...
            break;
        case 'black':
            //...
            break;
        default:
            //...
            break;
    }
    
```

从性能角度来看，大多数情况下switch比if-else运行得要快，但只有当条件数量很大时才明显。主要原因是，在JavaScript中，switch语句比较值时使用的是全等操作，不会发生类型转换的损耗。
因此，通常来说，if-else适用于判断两个离散值或几个不同的值域；当判断多于两个离散值时，switch更合适。


####4.3.2优化if-else
优化if-else的目标是：最小化到达正确分支前所需要判断的条件数量。最简单的优化方法是确保最可能出现的条件放在首位，即if-else中的条件语句应该总是按照从最大概率到最小概率的顺序排列，以确保运行速度最快。

####4.3.3使用查找表
当有大量离散值需要判断时，最佳方案是使用查找表。JavaScript中可以用数组和普通的Ojbect对象来构造查找表，通过查找表访问数据比if-else和switch都要快很多，特别是在条件数量很大的时候。而且，查找表结构的代码可读性更好。

``` javascript

    //定义一系列离散值对应的处理函数
    var handlers = {
        'red': function () {
            //处理 case 为 'red' 的分支
        },
        'blue': function () {
            //处理 case 为 'blue' 的分支
        },
        'yellow': function () {
            //处理 case 为 'yellow' 的分支
        },
        'black': function () {
            //处理 case 为 'black' 的分支
        }
    };
    
    //1.命名模式： 对每个函数进行命名。会产生两个中间的局部变量。
    var fn = handlers[color] || function () {
        //处理 default 的分支
    };
    fn();
    
    //2.混合模式：立即函数 + 声明即调用混合模式。 产生一个中间局部变量。
    (handlers[color] || function () {
        //处理 default 的分支
    })();
    
    
    //3.完全的声明即调用模式：追求极致的，不产生任何中间的局部变量。
    (({
        'red': function () {
            //处理 case 为 'red' 的分支
        },
        'blue': function () {
            //处理 case 为 'blue' 的分支
        },
        'yellow': function () {
            //处理 case 为 'yellow' 的分支
        },
        'black': function () {
            //处理 case 为 'black' 的分支
        }
    })[color] || function () {
        //处理 default 的分支
    })();
    
```

当你使用查找表时，必须完全抛弃条件判断语句。这个过程变成数组项查询或对象成员查询。查找表的一个主要优点是：不用书写任何条件判断语句，即使离散值数量增加时，也几乎不会产生额外的性能开销。当单个键和单个值之间存在逻辑映射时，查找表的优势就能体现出来。Switch语句更适合于每个键都需要对应一个独特的动作或一系列的动作的场合。

###4.4一些优化建议

####4.4.1避免动态执行字符串代码
JavaScript允许你动态去执行一个字符串代码，它比直接执行代码的速度慢很多，因为它要创建一个新的解释器/编译器实例，这必然使得代码执行速度变慢。
大多数时候，没有必要使用eval()和Function()，因此最好避免使用它们。另外，对于setTimeout()和setInterval()，建议传入函数的而不是字符串作为第一个参数。

####4.4.2使用直接量
在JavaScript中创建对象和数组的方法有多种，但使用直接量是最快的方法。字面量是引擎直接解释执行的，而如果使用构造函数的话，需要调用一个内部构造器。最重要一点，使用直接量有助于节省代码量，代码也更易读，数据结构更清晰。数据量越大，使用直接量的处好就越明显。

####4.4.3使用原生方法
无论你的JavaScript代码如何优化，都永远不会比JavaScript引擎提供的原生方法更快。因为，JavaScript的原生部分是用低级语言（如C++）写的，并被编译成机器码，成为执行环境（如浏览器）的一部分，所以不会像你写的JavaScript代码那样受到各种限制。
当原生方法可用时，尽量使用它们。特别是数学运算和DOM操作。用编译后的代码做越多的事情，你的代码就越快。

####4.4.4使用布尔表达式的短路
在很多语言中，如果bool表达式的值已经能通过前面的条件确定，那么后面的判断条件将不再会执行。因此，可以对多个“&&”和多个“||”操作的布尔表式进行位置上的排列优化：
	- 多个“&&”操作：尽量把能确定为false的子表达式放在前面。当前面有一个为false时，整个表达式的值为 false，后面的子表达式将不会计算；
	- 多个“||”操作：尽量把能确定为true的子表达式放在前面。当前面有一个为true时，整个表达式的值为 true，后面的子表达式将不会计算；

####4.4.5让垃圾回收器回收那些不再需要的对象
如果长时间保存对象，老生代中占用的空间将增大，每次在老生代中的垃圾回收过程将会相当漫长。在某些时候我们可以通过手动消除引用关系来让垃圾回收器对回收这些对象。
	- delete。一种方式是通过delete方式来消除对象中的键值对，从而消除引用。但这种方式并不提倡，它会改变对象的结构，可能导致引擎中对对象的存储方式变更，降级为字典方式进行存储，不利于JavaScript引擎的优化，所以尽量减少使用。
	- null。另一种方式是通过将值设为null来消除引用。通过将变量或对象的属性设为null，可以消除引用，使原本引用的对象成为一个“孤岛”，然后在垃圾回收的时候对其进行回收。这种方式不会改变对象的结构，比使用delete要好。

####4.4.6不要重复工作
对于一些比较复杂的计算，当相同的参数输入会得到相同的结果输出时，我们可以在函数内部把计算结果缓存起来。在下次进行同样的参数输入时，可以直接从缓存中读取结果，避免重复计算。这是一种典型的以空间换时间的策略，可以减少响应时间，提升用户体验。该方式适用于：
	相同的参数输入会得到相同的结果输出；
	能牺牲一定的内存空间；





##5.推荐的编程实践
###5.1不是你的对象不要动
JavaScript独一无二之处在于任何东西都不是神圣不可侵犯的。默认情况下，你可以修改任何你可以触及的对象。解析器根本不在乎这些对象是开发者定义的还是默认执行环境的一部分，只要能访问到的对象都可以修改。在一个开发者独自开发的项目中，这不是问题，开发者确切知道正在修改什么，因为他对所有代码都了如指掌。然而，在一个多人开发的项目中，对象的随意修改就是个大问题了。

####5.1.1什么对象不是你的
当你的代码创建了某些对象时，你就拥有这些对象。创建了对象的代码也许没必要一定由你来编写，但只要维护代码是你的责任，那么就是你拥有这些对象。举例来说，YUI团队拥有该YUI对象，jQuery团队拥有jQuery对象。即使编写代码定义该对象的原始作者离开了，各自对应的团队仍然是这些对象的拥有者。
当在项目中使用一个JavaScript类库，你个人不会自动变成这些对象的拥有者。在一个多人开发的项目中，每个人都假设库对象会按照它们的文档描述的一样正常工作。如果你在使用jQuery，修改了其中的对象，那么这就给你自己的团队设置了一个陷阱。这必将导致一些问题，有些人可能会掉进去。
请不要修改以下这些对象，因为它们是你项目执行环境的一部分。
	- 原生对象（如Object、Array等）。
	- 原型对象（如Object.prototype、Array.prototype等）。
	- DOM对象（如 document等）。
	- 类库对象（如jQuery等）。

####5.1.2原则
企业软件需要一致而可靠的执行环境使其方便维护。在JavaScript中，我们对不属于我们的对象应遵循如下原则：
	不覆盖方法。在JavaScript中，我们不应覆盖一个不属于我们的对象的方法。因为这会让JavaScript库和其他依赖该方法的代码都失效，带来难以置信的麻烦，跟踪和解决该问题会浪费大量的时间和精力。
	不新增方法。当一个对象此刻没有某个方法不代表它未来也没有，如果将来原生的方法和你新增的方法的行为不一致，你将陷入一场代码维护的噩梦。特别是不能给原生对象（如Object、Array等）的原型增加方法，因为你不可能精确预测JavaScript未来会如何变化；而且这会给团队的其他成员带来困惑，因为他们的预期中并不存在这些方法。
	不删除方法。删除一个在用的方法会可能导致运行时错误，因为使用该方法的业务代码可能有很多。如果不使用该方法，应该将其标识为“废弃”，可以用文档标识出来。

###5.2模块化你的代码

####5.2.1全局变量带来的问题
一般来说，创建全局变量被认为是糟糕的实践，尤其是在团队开发的大背景下更是隐患多。随着代码量的增长，全局变量会导致一些非常重要的可维护性难题。全局变量越多，引入错误的概率就越大。
	命名冲突。当全局变量和全局函数越来越多时，发生命名冲突的概率也随之增高，很可能无意间使用了一个已经声明的变量，也很可能把一个已经存在的全局变量覆盖了而导致发生一些意外的行为。所有的变量都应该定义成局部变量，这样的代码才是最容易维护的。
	代码脆弱。一个依赖于全局变量的函数即是深耦合于上下文环境之中，如果环境发生改变，函数就可能失效。当定义函数时，最好尽可能多地将数据置于局部作用域内。任何来自函数外部的数据都应当以参数形式传进来。这样可以将函数和其外部环境隔离开来，你的修改不会对程序其他部分产生影响。
	难以测试。任何依赖全局变量才能正常工作的函数，只有为其重新创建完整的全局变量环境才能正确的测试它。当变换了环境，如从研发环境转到测试环境，保持两者的同步是很消耗成本的。确保函数不会对全局变量产生依赖，可以增强代码的可测试性。对于一些原生的JavaScript全局对象，比如Date、Array等，它们是全局环境的一部分，是和JavaScript引擎相关的，可以不必考虑。


















